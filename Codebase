import time
import numpy as np
from PIL import Image

# These helper functions will allow us to perform each step of the k-medioids algorithm.
# I will define all functions first, then put them all together into a single implementation. 

# Step 1. Read in the data and manipulate images to the desired format.
def image_to_array(image):
    width = image.size[0]
    height = image.size[1]
    return (width, height, np.array(image, dtype='int16').reshape(width*height, 3))

def array_to_image(width, height, image_array):
    assert isinstance(width, int)
    assert isinstance(height, int)
    image_array = image_array.astype(np.uint8)
    return Image.fromarray(image_array.reshape(height, width, 3))

##################################################################
# Read the image and convert to array
# im = Image.open('beach.bmp')
# width, height, im_array = image_to_array(im)
# display(im)
##################################################################

# Step 2. initialize the medioids.
def initialize_medioids(image_array, K, rand_seed=1):
    np.random.seed(rand_seed)
    medioids = np.random.choice(len(image_array), replace=False, size=K)
    return image_array[medioids, :]

##################################################################
# medioids = initialize_medioids(im_array, 5)
##################################################################


# Step 3. Calculate distances from each point to the medioid of each cluster
def calculate_distances_to_medioids(image_array, medioids, l_norm=2):
    num_points = len(image_array)
    K = len(medioids)
    dists = np.zeros((num_points, K))
    
    for i in range(num_points):
        dist = np.linalg.norm(image_array[i,:] - medioids, axis=1, ord=l_norm)
        dists[i,:] = dist**l_norm
    
    return dists

##################################################################
# distances = calculate_distances_to_medioids(im_array, medioids)
##################################################################

# Step 4. Assign each data point to a cluster based on the distances calculated in step 3.
def assign_each_point_to_closest_medioid(dists):
    return np.argmin(dists, axis=1)
    
    
# Step 5. Update the medioids based on the fixed cluster assignments.
def update_medioids(image_array, medioids, l_norm=2):
    centers = np.zeros(medioids.shape)
    new_medioids = np.zeros(medioids.shape)
    distances = calculate_distances_to_medioids(image_array, medioids, l_norm)
    labels = assign_each_point_to_closest_medioid(distances)
    
    for cluster in set(labels):

        points_in_cluster = np.array([image_array[j] for j in range(len(image_array)) if labels[j] == cluster])
        centers[cluster] = np.mean(points_in_cluster, axis=0)
    
        # Calculate distance from each point in cluster to the cluster center.
        num_points = len(points_in_cluster)
        temp_distances = np.zeros(num_points)
    
        for i in range(num_points):
            dist = np.linalg.norm(points_in_cluster[i,:] - centers[cluster], ord=l_norm)
            temp_distances[i] = dist**l_norm
        
        # Assign the point that is closest to the center to be the new medioid.
        new_medioids[cluster] = points_in_cluster[np.argmin(temp_distances)]

    return new_medioids

##################################################################
# new_medioids = update_medioids(im_array, medioids, l_norm=2)
##################################################################


# Step 6. 
def check_for_convergence(medioids, new_medioids):
    return np.array_equal(medioids, new_medioids)

# Putting it all together.
def k_medioids(pixels, K, max_iterations = 10, l_norm = 2):
    print('Running k_medioids...')
    t0 = time.time()
    image_array = pixels  # To fit the naming convention outlined in the assignment...
    converged = False
    medioids = initialize_medioids(pixels, K)
    iteration = 1
    
    while (not converged) and (iteration < max_iterations):
#         print('Iteration: ', iteration)

        distances = calculate_distances_to_medioids(image_array, medioids, l_norm)
        labels = assign_each_point_to_closest_medioid(distances)
        new_medioids = update_medioids(pixels, medioids)
        
        converged = check_for_convergence(medioids, new_medioids)
        medioids = new_medioids
        iteration += 1

        
    class_ = labels        # To fit the naming convention outlined in the assignment...
    centroids = medioids  # To fit the naming convention outlined in the assignment...
    t1 = time.time()
    runtime = round(t1-t0)
    
    return class_, centroids, iteration, runtime
        
